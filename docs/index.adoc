= BLisp: A Statically Typed Lisp Like Language
Yuuki Takano <ytakano@wide.ad.jp>
v0.1, 2021-02
:doctype: article
:toc:
:sectnums:
:encoding: utf-8
:stem: latexmath
:source-highlighter: pygments


BLisp is a statically typed Lisp like programming language which adopts effect system for no_std environments.
BLisp supports higher order RPC like higher order functions of functional programing languages.

This repository provides only a library crate.
Please see https://github.com/ytakano/blisp-repl[blisp-repl] to use BLisp,
and https://github.com/ytakano/baremetalisp[baremetalisp] which is a toy OS.

== Features

* Algebraic data type
* Generics
* Hindleyâ€“Milner based type inference
* Effect system to separate side effects from pure functions
* Big integer
* Supporting no_std environments

== Values

.values
[source, lisp]
----
144       ; integer value
true      ; boolean value
false     ; boolean value
[true 10] ; tuple
[]        ; empty tuple
'(1 2 3)  ; list
'()       ; empty list, Nil
----

== Basic Types

.types
[source, lisp]
----
Int        ; signed integer
Bool       ; boolean
'(Int)     ; list of Int
[Int Bool] ; tuple of Int and Bool
(Pure (-> (Int Int) Bool)) ; Pure function, which takes 2 integers and return boolean value
(IO (-> (Int) [])) ; IO function, which takes an integer and return []
----

Pure and IO are function effects.
In IO functions, both Pure and IO functions can be called.
However, in Pure functions, calling only Pure functions is permitted.

== Function Definition

Functions can be defined by defun or export.
"defun" defines a local function which cannot be called from Rust's eval function.

Suppose following 2 functions.

.defun
[source, lisp]
----
(defun double (x)         ; function name is "double" and "x" is an argument
    (Pure (-> (Int) Int)) ; function Type
    (* 2 x))              ; function body
----

.export
[source, lisp]
----
(export quad (x)          ; function name is "quad" and "x" is an argument
    (Pure (-> (Int) Int)) ; function Type
    (double (double x)))  ; function body
----

double cannot be called from Rust's eval, but can be called from internally defined functions.
qued can be called from Rust's eval, and it calls double internally.

This is the code what actually do in Rust.

.Rust's eval
[source, rust]
----
use blisp;

fn eval(e: &str, ctx: &blisp::semantics::Context) {
    // evaluate expressions
    let exprs = match blisp::eval(e, ctx) {
        Ok(es) => es,
        Err(err) => {
            println!("error:{}:{}: {}", err.pos.line, err.pos.column, err.msg);
            return;
        }
    };

    for r in exprs {
        match r {
            Ok(msg) => {
                println!("{}", msg);
            }
            Err(msg) => {
                println!("error: {}", msg);
            }
        }
    }
}

fn main() {
    // internal code
    let code = "
(defun double (x)         ; function name is double and x is an argument
    (Pure (-> (Int) Int)) ; function Type
    (* 2 x))              ; function body

(export quad (x)          ; function name is quad and x is an argument
    (Pure (-> (Int) Int)) ; function Type
    (double (double x)))  ; function body
";
    let exprs = blisp::init(code).unwrap();
    let ctx = blisp::typing(&exprs).unwrap();

    let e = "(double 10) ; error";
    eval(e, &ctx);

    let e = "(quad 10) ; OK";
    eval(e, &ctx);
}
----

This code output as follows.

 error:0:1: Typing Error: double is not defined
 40

== Arithmetic Operations

.basic
[source, lisp]
----
; (Pure (-> (Int Int) Int))
(+ 10 20)
(- 30 40)
(* 6 100)
(/ 100 2)
(% 10 3)
----

.comparison
[source, lisp]
----
; (Pure (-> (Int Int) Bool))
(= 4 4)
(< 6 7)
(> 6 7)
(<= 30 40)
(>= 30 40)
----

== Boolean Operations

.logical
[source, lisp]
----
; (Pure (-> (Bool Bool) Bool))
(and true false)
(or true false)
(xor true false)
----

.negation
[source, lisp]
----
; (Pure (-> (Bool) Bool))
(not true)
----

== Algebraic Data Type

Algebraic data type can be defined as follows.

```lisp
; in BLisp
(data Gender ; type name
    Male     ; value
    Female)  ; value
```

Type name's and its value's first character must be uppercase.
This is equivalent to Rust's following code.

```rust
// in Rust
enum Gender {
    Male,
    Female
}
```

Each element can have values as follows.

```lisp
; in BLisp
(data Dim2
    (Dim2 Int Int)) ; Dim2 has integers
```

Dim2 can be instantiated as follows.

```lisp
(Dim2 10 20)
```

This type is equivalent to as follows.

```rust
// in Rust
use num_bigint::BigInt;
enum Dim2 {
    Dim2(BigInt, BigInt)
}
```

== Generics

Option and Result types are defined internally.

```lisp
(data (Option t)
    (Some t)
    None)

(data (Result t e)
    (Ok t)
    (Err e))
```

_t_ and _e_ are type variables.
This code is equivalent to following Rust's code.

```rust
// in Rust
enum Option<t> {
    Some(t),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

List type is a built-in type as follows.

```lisp
(data (List t)
    (Cons t (List t))
    Nil)
```

So, following 2 lists are equivalent.

```lisp
(Cons 1 (Cons 2 (Cons 3 Nil)))
'(1 2 3)
```

== Generic Function

_car_ and _cdr_ are internally defined generic functions.
These definitions are as follows.

```lisp
(export car (x) (Pure (-> ('(t)) (Option t)))
    (match x
        ((Cons n _) (Some n))
        (_ None)))

(export cdr (x) (Pure (-> ('(t)) '(t)))
    (match x
        ((Cons _ l) l)
        (_ '())))
```

_t_ is a type variable. These functions can be used as follows.

```lisp
(car '(3 8 9))  ; returns (Some 3)
(cdr '(8 10 4)) ; returns '(10 4)
```

Normal and type variables' first character must be lowercase.

== If Expression

Straightforward.

```lisp
(if (< 10 20)
    '(1 2 3)
    '())
```

== Match Expression

A list can be matched as follows.

```lisp
(match '(1 2 3)
    ((Cons n _) n)
    ('() 0))
```

The expression

 (Cons n _)

is a pattern.
If the pattern is matched to '(1 2 3), 1 is assigned to a varable _n_. Then, _n_, namely 1, is returned.

This is an example of pattern matching of tuple.

```lisp
(match [1 3]
    ([x y] [y x]))
```

This code swap 1st and 2nd elements of the tuple.

Integer values can be also used for pattern matching.

```lisp
(match 20
    (20 true)
    (_ false))
```

More complex example is a as follows.

```lisp
(match [(Some 10) true]
    ([(Some 10) false] 1)
    ([(Some 10) true] 2)
    (_ 0))
```

BLisp checks exhaustively of pattern.
So, following code will be rejected.

```lisp
(match '(1 2)
    ('() 0))
```

== Let Expression

Let expression is used to bind variables as follows.

```lisp
(let ((x 10) (y 20)) ; x is 10, y is 20
    (* x y))

(let ((x 10) (x (* x x)) (x (* x x))) ; x = 10, x = x * x, x = x * x
    x)
```

Destructuring can be also performed as follows.

```lisp
(let (((Some x) (Some 10))) ; x is 10
    (* x 2))

(let (([x y] [10 20])) ; x is 10, y is 20
    (* x y))
```

== Lambda Expression

Lambda expression is defined as follows.

```lisp
(lambda (x y) (* x y))
```

This lambda takes 2 integers and return the multiplication.
Applying arguments to this is simple as follows.

```lisp
((lambda (x y) (* x y)) 10 20)
```

Every lambda expression is Pure.
IO functions cannot be called in any lambda expressions.

_map_ and _fold_ functions are internally defined as follows.

```lisp
(export map (f x) (Pure (-> ((Pure (-> (a) b)) '(a)) '(b)))
    (match x
        ((Cons h l) (Cons (f h) (map f l)))
        (_ '())))

(export fold (f init x) (Pure (-> ((Pure (-> (a b) b)) b '(a)) b))
    (match x
        ((Cons h l) (fold f (f h init) l))
        (_ init)))
```

_map_ can be used to apply functions to elements of a list as follows.

```lisp
; square each element
(let ((l '(1 2 3))
      (f (lambda (x) (* x x))))
        (map f l))
```

_fold_ can be used to calculate over elements of a list.
For example, summation can be computed as follows.

```lisp
; summation
(let ((l '(20 50 60))
      (f (lambda (x y) (+ x y))))
        (fold f 0 l)) ; 0 is an initial value
```
